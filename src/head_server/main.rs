#![feature(futures_api, arbitrary_self_types, await_macro, async_await)]

#[macro_use]
extern crate lazy_static;

extern crate clap;
extern crate rand;
extern crate sharedlib;
extern crate tarpc;
extern crate tarpc_bincode_transport;
extern crate tokio;

mod round;

use crate::tarpc::futures::compat::Executor01CompatExt;
use crate::tarpc::futures::FutureExt;
use crate::tarpc::futures::TryFutureExt;

use clap::{App, Arg};
use std::collections::HashMap;

use tarpc::server::Handler;
use tarpc_bincode_transport::listen;

use sharedlib::head_rpc::serve;
use sharedlib::head_rpc::HeadServer;

use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use std::{io, thread, time};

use crate::round::{
    cleanup, end_round, round_status_check, send_m_vec, start_round, waiting_for_next,
};
use sharedlib::head_rpc::{
    BACKWARDS_MESSAGES, LOCAL_ROUND_ENDED, MESSAGES, PROCESSED_BACKWARDS_MESSAGES,
};
use tarpc::server;
use tokio_threadpool::ThreadPool;

lazy_static! {
    // quick hack to get args into callback function without modifying the
    // cursive lib / making a custom UI object
    static ref HASHMAP: HashMap<String, String> = {
        let mut m = HashMap::new();
        let matches = App::new("Vuvuzela Head Server")
                        .version("1.0")
                        .about("Vuvuzela Head Server")
                        .author("Sam Ginzburg")
                        .author("Benjamin Kuykendall")
                        // this effectively corresponds to the id # for key lookup
                        .arg(Arg::with_name("server_id")
                            .short("id")
                            .long("server_id")
                            .help("Specifies which server keypair to use")
                            .takes_value(true))
                        .get_matches();

        let server_uid = String::from(matches.value_of("server_id").unwrap_or("0").clone());

        m.insert(String::from("server_id"), server_uid);
        m.clone()
    };
}

async fn run_service(_server_addr: &str, port: u16) -> io::Result<()> {
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), port);
    let transport = listen(&server_addr)?;
    let _addr = transport.local_addr();

    // The server is configured with the defaults.
    let server = server::new(server::Config::default())
        // Server can listen on any type that implements the Transport trait.
        .incoming(transport)
        // serve is generated by the service! macro. It takes as input any type implementing
        // the generated Service trait.
        .respond_with(serve(HeadServer));

    await!(server);

    Ok(())
}

fn main() {
    tarpc::init(tokio::executor::DefaultExecutor::current().compat());
    // TODO: set ip/port combo via cli flags
    let pool = ThreadPool::new();

    pool.spawn(
        run_service("", 8080)
            .map_err(|e| eprintln!("RPC Error: {}", e))
            .boxed()
            .compat(),
    );

    // start fetching data from server once GUI is initialized
    let handler = thread::spawn(move || {
        loop {
            {
                let mut p_backwards_msgs_m_vec = BACKWARDS_MESSAGES.lock().unwrap();
                *p_backwards_msgs_m_vec = vec![];

                // reset the 'messages received' buffer at the start of each round
                let mut p_backwards_m_vec = PROCESSED_BACKWARDS_MESSAGES.lock().unwrap();
                *p_backwards_m_vec = vec![];
            }
            // wait until round ends
            thread::sleep(time::Duration::from_millis(2000));
            // acquire lock on MESSAGES
            println!("Starting round!!");
            let mut m_vec = MESSAGES.lock().unwrap();
            println!("m_vec lock acquired!");

            let shuffle = round_status_check(m_vec.to_vec(), "127.0.0.1".to_string(), 8081);
            // signal int_server to start round
            let start_new_round =
                shuffle.and_then(|(s, v)| start_round(s, v, "127.0.0.1".to_string(), 8081));
            // begin sending messages in batches
            let send_msgs =
                start_new_round.and_then(|(s, v)| send_m_vec(s, v, "127.0.0.1".to_string(), 8081));
            // signal end of round
            let end_round =
                send_msgs.and_then(|(s, v)| end_round(s, v, "127.0.0.1".to_string(), 8081));
            let wait = end_round.and_then(|(s, _)| waiting_for_next(s));
            let cleanup = wait.and_then(|s| cleanup(s));

            tokio::run(
                (cleanup)
                    .map_err(|e| eprintln!("Fetch Error: {}", e))
                    .boxed()
                    .compat(),
            );

            // empty our message buffer for the next round
            *m_vec = vec![];
            // cleanup end round cvar
            let tuple = LOCAL_ROUND_ENDED.clone();
            let &(ref b, _) = &*tuple;
            let mut flag = b.lock().unwrap();
            *flag = false;
        }
    });

    handler.join().unwrap();
}
